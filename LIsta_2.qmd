---
title: "Lista 2"
author: "Arthur Sá Saydelles"
format: html
editor: visual
---

## Questão 1

```{r}

x <- seq(3, 6, by = 0.1)
y <- exp(x) * cos(x)
y

```

## Questão 2

### A)

```{r}

a <- 0.1^(seq(3, 36, by = 3)) * 0.2^(seq(1, 34, by = 3))
a
```

### B)

```{r}
b <- 2^(1:25) / (1:25)
b

```

## Questão 3

```{r}
dds <- c(domingo = 1,
         segunda = 2,
         terca   = 3,
         quarta  = 4,
         quinta  = 5,
         sexta   = 6,
         sabado  = 7)

dds

```

## Questão 4

```{r}
# Interprete o resultado da seguinte operação:
dds_nums <- c(
  5L, 2L, 5L, 2L, 7L, 7L, 2L,
  6L, 6L, 3L, 7L, 1L, 2L, 2L,
  5L, 7L, 3L, 2L, 6L, 4L, 1L
)
names(dds)[dds_nums]
```

A operação traduz números em nomes dos dias da semana. Assim, "dds_nums" armazena códigos (1 a 7), onde o (L) significa inteiro, e "names(dds)\[dds_nums\]" devolve o nome correspondente a cada dia da semana.

## Questão 5

### A)

```{r}
valores <- c(85, 79, 70, 6, 32, 8, 17, 93, 81, 76)
pares <- valores %% 2 == 0
pares
```

### B)

```{r}
total_impares <- sum(!pares)
total_impares
```

O número total de ímpares foi de `r total_impares`

## Questão 6

```{r}

anos <- c(1894, 1947, 1901, 1992, 1925, 2014, 1993, 1996, 1984, 1897, 2100, 2300)

bissexto <- function(ano) {
  # Se divisível por 4 → bissexto
  if (ano %% 4 == 0) {
    return(TRUE)
  }
  # Se divisível por 100 → NÃO bissexto
  if (ano %% 100 == 0) {
    return(FALSE)
  }
  # Se divisível por 400 → bissexto
  if (ano %% 400 == 0) {
    return(TRUE)
  }
  # Caso contrário → não bissexto
  return(FALSE)
}

anos_bissextos <- anos[sapply(anos, bissexto)]

```

Os anos bissextos são: `r anos_bissextos`

## Questão 7

### A)

```{r}
A <- c(-30, 0, 5, 10, 15, 20, 30)
A
```

### B)

```{r}
B <- c(1.0, 0.8, 0.6, 0.4, 0.2, 0.0)
B
```

### C)

```{r}
C <- c(-3.1415927, -2.4434610, -1.7453293, -1.0471976, -0.3490659,  0.3490659, 1.0471976, 1.7453293,  2.4434610,  3.1415927)
C

```

### D)

```{r}
D <- c(
  rep(-1, 2),
  rep(0, 3),
  rep(1, 4),
  rep(2, 5),
  rep(3, 6),
  rep(4, 7),
  rep(5, 8)
)
D
```

### E)

```{r}
E <- c(
  rep(5, 5),
  rep(4, 4),
  rep(3, 3),
  rep(2, 2),
  rep(1, 1),
  rep(2, 2),
  rep(3, 3),
  rep(4, 4),
  rep(5, 5)
)
E
```

## Questão 8

### A)

```{r}

v3 <- c(11, 0.25, 7, 2)
seq_along(v3)

```

### B)

```{r}

v2 = c(11, 0.25)
seq_along(v2)

```

### C)

```{r}

v1 = c(11)
seq_along(v1)

```

### D)

```{r}

v0 = c()
seq_along(v0)

```

## Questão 9

### A)

```{r}
tar_est1 <- c(
14.92, 14.61, 14.32, 14.07, 13.84, 13.65, 13.56, 13.97, 15.08,
16.5, 17.88, 19.08, 20.02, 20.66, 21.01, 21.05, 20.76, 20.05,
18.77, 17.51, 16.67, 16.11, 15.66, 15.27
)
tar_est2 <- c(
13.13, 13.01, 12.93, 12.87, 12.82, 12.81, 13.2, 14.22, 15.77,
17.49, 19.2, 20.57, 21.49, 22.01, 22.03, 21.71, 20.84, 18.77,
16.54, 15.13, 14.34, 13.81, 13.49, 13.28
)
tmed_est1 <- round(mean(tar_est1), 1)
tmed_est2 <- round(mean(tar_est2), 1)
tmed_est1
tmed_est2
```

A temperatura média na estação 1 é de `r stringr::str_replace(tmed_est1, "\\.", ",")` °C e da estação 2 é `r stringr::str_replace(tmed_est2, "\\.", ",")` °C.

### B)

```{r}

tmed_est1 > tmed_est2
#tmed_est2 > tmed_est1

```

A temperatura média do ar é maior na estação `r ifelse(tmed_est1 > tmed_est2, "1", "2")`.

### C)

```{r}
terc_maior_est1 <- sort(tar_est1, decreasing = TRUE)[3]
terc_maior_est2 <- sort(tar_est2, decreasing = TRUE)[3]
terc_maior_est1
terc_maior_est2
```

A terceira maior temperatura na estação 1 (2) é de `r stringr::str_replace(terc_maior_est1, "\\.", ",")` °C (`r stringr::str_replace(terc_maior_est2, "\\.", ",")` °C).

### D)

```{r}
atd_est1 <- round(max(tar_est1)-min(tar_est1), 1)
atd_est2 <- round(max(tar_est2)-min(tar_est2), 1)
atd_est1
atd_est2
```

A amplitude térmica na estação 1 (2) é de `r stringr::str_replace(atd_est1, "\\.", ",")` °C (`r stringr::str_replace(atd_est2, "\\.", ",")` °C).

### E)

Horários da Temperatura máxima:

```{r}
horas <- 0:23
#tmax <- max(tar_est1)
# which(tar_est1 == tmax)
#horas[tar_est1 == tmax]

(hmax_est1 <- horas[which.max(tar_est1)])
(hmax_est2 <- horas[which.max(tar_est2)]) 

```

Horários da Temperatura mínima:

```{r}
horas <- 0:23
tmin <- min(tar_est1)
# which(tar_est1 == tmax)
#horas[tar_est1 == tmax]

(hmin_est1 <- horas[which.min(tar_est1)])
(hmin_est2 <- horas[which.min(tar_est2)]) 
```

O horário da Tmax na estação 1 (2) é de `r hmax_est1` horas (`r hmax_est2` horas).

O horário da Tmin na estação 1 (2) é de `r hmin_est1` horas (`r hmin_est2` horas).

### F)

```{r}
# Etapas
# quando a T2 > T1 extrair T2
#cond: condiçao (T2 > T1)
tar2_cond <- tar_est2[tar_est2 > tar_est1] 

# quando a T1 > T1 extrair T1
#cond: condiçao (T2 > T1)
tar1_cond <- tar_est1[tar_est2 > tar_est1] 

# calcula a diferença absoluta de cada

abs(tar2_cond - tar1_cond)
tmax_dif_cond <- max(abs(tar2_cond - tar1_cond))

```

A maior diferença é de `r stringr::str_replace(tmax_dif_cond, "\\.", ",")` °C.

### G)

```{r}
# horas quando T2 > T1
horas_cond <- horas[tar_est2 > tar_est1]

horas_cond[which.max(abs(tar2_cond - tar1_cond))]

# solução 2
dif_tar <- tar2_cond - tar1_cond
# horas quando T2 > T1
horas_cond <- horas[tar_est2 > tar_est1]
horas_cond[dif_tar == tmax_dif_cond]

```

A hora correspondende a ocorrência da maior diferença absoluta de temperatura é `r horas_cond[dif_tar == tmax_dif_cond]` horas

### H)

Para estação 1:

```{r}
# O horário do pôr do sol pode ser estimado a partir da Tar. 

# Para o período após o horário de ocorrência da Tmax

pos_hmax_est1 <- which.max(tar_est1)
pos_depois_tmax1 <- pos_hmax_est1:length(tar_est1)

# valores de T após ter ocorrido a Tmax

tar_pos_tmax1 <- tar_est1[pos_depois_tmax1]
diff_tar1 <- tar_pos_tmax1 - dplyr::lag(tar_pos_tmax1)

# posição
pos_ps1 <- which.min(diff_tar1)

# determina-se em qual hora ocorre a maior queda de Tar em relação a hora anterior. 

horas[pos_depois_tmax1][pos_ps1]

```

Para estação 2:

```{r}
# O horário do pôr do sol pode ser estimado a partir da Tar. 

# Para o período após o horário de ocorrência da Tmax

pos_hmax_est2 <- which.max(tar_est2)
pos_depois_tmax2 <- pos_hmax_est1:length(tar_est2)

# valores de T após ter ocorrido a Tmax

tar_pos_tmax2 <- tar_est2[pos_depois_tmax2]
diff_tar2 <- tar_pos_tmax2 - dplyr::lag(tar_pos_tmax2)

# posição
pos_ps2 <- which.min(diff_tar2)

# determina-se em qual hora ocorre a maior queda de Tar em relação a hora anterior. 

horas[pos_depois_tmax2][pos_ps2]

```

O horário estimado do pôr do sol na primeira estação é `r horas[pos_depois_tmax1][pos_ps1]` horas.

O horário estimado do pôr do sol na primeira estação é `r horas[pos_depois_tmax2][pos_ps2]` horas.

### I)

```{r}

horas_prox_05 <- 0:23
dif_abs <- abs(tar_est1 - tar_est2)

horas_proximas <-horas_prox_05[dif_abs < 0.5]

```

As horas em que as temperaturas das duas estações estão mais próximas uma da outra são: `r horas_proximas` horas.

### J)

```{r}
Tmax2 <- max(tar_est2)
Tmin2 <- min(tar_est2)

# Método 1
tar_met1 <- (Tmax2 + Tmin2)/2

# Método 2
T9  <- tar_est2[10]
T21 <- tar_est2[22]

tar_met2 <- (Tmax2 + Tmin2 + T9 + 2*T21)/5

# Método 3
T7  <- tar_est2[8]
T14 <- tar_est2[15]

tar_met3 <- (T7 + T14 + 2*T21)/4

```

Usando o método 1 a temperatura média diária foi de `r stringr::str_replace(tar_met1, "\\.", ",")` °C.

Usando o método 2 a temperatura média diária foi de `r stringr::str_replace(tar_met2, "\\.", ",")` °C.

Usando o método 3 a temperatura média diária foi de `r stringr::str_replace(tar_met3, "\\.", ",")` °C.

### K)

```{r}

dif_met1 <- abs(tar_met1 - tmed_est2)
dif_met2 <- abs(tar_met2 - tmed_est2)
dif_met3 <- abs(tar_met3 - tmed_est2)

```

O método 2 ficou com a menor diferença absoluta em relação a "tmed_est2", portanto é o que mais se aproxima da média real.

## Questão 10

### A)

```{r}
#Função do modelo de onda
modelo_onda <- function(Tmax, Tmin, hTmax, hTmin, horas) {
  # Temperatura média e amplitude
  Tmed <- (Tmax + Tmin) / 2
  A    <- (Tmax - Tmin) / 2
  
  # Proteção contra dados incorretos
  if (is.na(hTmax) || is.na(hTmin)) {
    stop("hTmax ou hTmin contém NA — verifique os dados.")
  }
  if (hTmax == hTmin) {
    hTmax <- hTmax + 1
    warning("hTmax e hTmin eram iguais — ajustado automaticamente.")
  }
  
 
  Tcalc <- numeric(length(horas))
  
  for (i in seq_along(horas)) {
    hora <- horas[i]
    
    if (hora < hTmin) {
      denom <- (10 + hTmin)
      if (denom == 0) denom <- 1
      arg <- pi * (hora + 10) / denom
      Tcalc[i] <- Tmed + A * cos(arg)
      
    } else if (hora >= hTmin & hora < hTmax) {
      denom <- (hTmax - hTmin)
      if (denom == 0) denom <- 1
      arg <- pi * (hora - hTmin) / denom
      Tcalc[i] <- Tmed - A * cos(arg)
      
    } else {
      denom <- (10 + hTmax - 24)
      if (denom == 0) denom <- 1
      arg <- pi * (14 - hora) / denom
      Tcalc[i] <- Tmed + A * cos(arg)
    }
  }
  
  
  Tcalc[is.nan(Tcalc)] <- NA_real_
  
  return(Tcalc)
}

# Para estação 1
Tmax1 <- max(tar_est1)
Tmin1 <- min(tar_est1)
hTmax1 <- which.max(tar_est1) - 1
hTmin1 <- which.min(tar_est1) - 1
tar_calc1 <- modelo_onda(Tmax1, Tmin1, hTmax1, hTmin1, horas)

# Para estação 2
Tmax2 <- max(tar_est2)
Tmin2 <- min(tar_est2)
hTmax2 <- which.max(tar_est2) - 1
hTmin2 <- which.min(tar_est2) - 1
tar_calc2 <- modelo_onda(Tmax2, Tmin2, hTmax2, hTmin2, horas)
```

### B)

```{r}
rmse1 <- sqrt(mean((tar_calc1 - tar_est1)^2))
rmse2 <- sqrt(mean((tar_calc2 - tar_est2)^2))
```

### C)

```{r}
r1 <- cor(tar_est1, tar_calc1)
r2 <- cor(tar_est2, tar_calc2)
```

O RMSE calculado para estação 1 (2) foi de `r stringr::str_replace(round(rmse1, 2), "\\.", ",")` °C (`r stringr::str_replace(round(rmse2, 2), "\\.", ",")` °C)

A correlação no caso 1 (2) foi de `r stringr::str_replace(round(r1, 5), "\\.", ",")` (`r stringr::str_replace(round(r2, 5), "\\.", ",")`)

## Questão 11

### A)

```{r}
# Dados
hora <- 9:21
prec <- c(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 21.4, 41.2, 2.6, 1.0, 0.4, 0.0)

prec_acum <- cumsum(prec)
prec_acum

diff_prec <- c(NA, diff(prec_acum))

```

"c(NA, diff(prec_acum))" ele calcula a diferença entre cada elemento consecutivo do vetor, porém ele adiciona NA na primeira posição, pois a primeira diferença não existe.

### B)

```{r}
indice_max <- which.max(prec)
hora_max <- hora[indice_max]
```

O horário que teve máxima precipitação foi às `r hora_max` horas

### C)

```{r}
hora_inicio <- hora[which(prec > 0)[1]]
hora_fim <- hora[tail(which(prec > 0), 1)]
duracao <- hora_fim - hora_inicio + 1
```

O horário de ínicio do evento foi às `r hora_inicio` horas.

O horário de final do evento foi às `r hora_fim` horas.

A duração do evento foi de `r duracao` horas.

### D)

```{r}
prec_total <- sum(prec[hora >= hora_inicio & hora <= hora_fim])
prec_ate_17 <- sum(prec[hora >= hora_inicio & hora <= 17])
percentual_ate_17 <- (prec_ate_17 / prec_total) * 100
```

A precipitação total do evento foi de `r stringr::str_replace(prec_total, "\\.", ",")` mm.

A precipitação até às 17h foi de `r stringr::str_replace(prec_ate_17, "\\.", ",")` mm.

A precipitação total do evento, em %, até às 17h foi de `r stringr::str_replace(round(percentual_ate_17, 3), "\\.", ",")` mm.

## Questão 12

```{r}
z <- c(11, 10, 15, 2, 6, -15, -10, -22, -8, 5, 7, 2, 12, 8, 4, 1, 3, -3, -1, 30, 14)

ultimo_negativo <- tail(which(z < 0), 1)

primeiro_positivo_apos <- z[(ultimo_negativo + 1):length(z)]
primeiro_positivo_apos <- primeiro_positivo_apos[primeiro_positivo_apos > 0][1]
```

O primerio número positivo depois do último negativo é `r primeiro_positivo_apos`.

## Questão 13

### A)

```{r}
# Vetor de precipitação
prec <- c(
  0, 0, 0, 0.8, 0, 0.01, 0.75, 0,
  0, 0, 0, 0.35, 0.08, 0, 0, 0, 0, 0.31, 0, 3.57, 12.17, 0, 0,
  0, 0.04, 3.16, 0, 0.95, 0.79, 0, 0, 0, 0, 0, 3.51, 0, 0, 0.16,
  0, 0, 8.16, 0.54, 4.39, 1.24, 0, 0, 0, 0, 0, 2.43, 0, 0, 0, 0,
  0, 7.18, 0, 0, 0.26, 0, 0, 0.28, 0, 0, 0.09, 0.38, 0, 0, 0, 0,
  0, 0, 0.51, 0, 0, 0, 0, 0, 0, 0.67, 0, 0, 0, 0, 0.15, 0, 0.82,
  0, 0, 0, 0, 0, 0, 0, 0, 0.37, 0, 0.58, 4.95, 0, 0, 0, 0, 0, 7.68,
  0, 0, 0.37, 0, 1.56, 0, 0, 0, 0.34, 0.48, 0, 4.21, 2.28, 4.3,
  0, 3.38, 0, 0, 0, 0, 7.28, 0, 4.89, 3.91, 0, 0, 0, 0, 0, 0, 2.93,
  0, 2.49, 0.77, 0, 2.9, 3.53, 0.83, 0, 0, 0, 0.94, 0.59, 0, 0,
  0, 0, 0.04, 0, 0.65, 0, 0, 0, 6.23, 0.09, 0, 0.66, 0, 0, 0, 4.42,
  0, 0, 0, 0.84, 0, 0, 0, 0, 0, 0.09, 0, 0, 0.08, 0, 0.66, 0, 0,
  0, 0.06, 0, 0, 0, 3.28, 0, 0.8, 5.69, 0.8, 0
)

dias_0_025 <- sum(prec > 0 & prec < 0.25)

```

A quantidade de dias que ficarem entre 0 e 0,25 foram `r dias_0_025` dias.

### B)

```{r}
prec[prec > 0 & prec < 0.25] <- 0
prec

```

### C)

```{r}
prec01 <- ifelse(prec >= 0.25, 1, 0)
prec01
```

### D)

```{r}
prob_chuva <- mean(prec01)
```

A probabilidade de chuva vai ser de `r stringr::str_replace(round(prob_chuva, 2), "\\.", ",")` %.

### E)

```{r}
n_dias <- length(prec01)

# Criar pares de dias consecutivos
dias_anteriores <- prec01[1:(n_dias-1)]
dias_posteriores <- prec01[2:n_dias]

p11 <- sum(dias_anteriores == 1 & dias_posteriores == 1)*100 / (n_dias - 1)

p01_p10 <- sum((dias_anteriores == 0 & dias_posteriores == 1) *100|
               (dias_anteriores == 1 & dias_posteriores == 0)) *100/ (n_dias - 1)

```

A probabilidade de chover em dois consecutivos é de `r stringr::str_replace(round(p11, 2), "\\.", ",")` %

A probabilidade de chover em qualquer um dos dois dias consecutivos `r stringr::str_replace(round(p01_p10, 2), "\\.", ",")` %

### F)

```{r}
seq_dias_chuv <- rle(prec01)
duracao_chuva <- seq_dias_chuv$lengths[seq_dias_chuv$values == 1]
names(duracao_chuva) <- paste0("evento", seq_along(duracao_chuva))
duracao_chuva

```

## Questão 14

### A)

```{r}
dados <- c(
  NA, NA, 27L, 7L, 4L, 0L, 26L, 15L, 25L, NA, NA, NA, NA, 6L,
  29L, 18L, 17L, 23L, 20L, 1L, 30L, 13L, NA, NA, NA, NA, NA, NA,
  NA, 19L
)


na_lógicos <- is.na(dados)

r <- rle(na_lógicos)

# Substituir valores TRUE (NA) por sequência e FALSE (não NA) por 0
resultado <- unlist(
  lapply(seq_along(r$lengths), function(i) {
    if (r$values[i]) {
      seq_len(r$lengths[i])  # sequencial dentro do bloco de NAs
    } else {
      rep(0, r$lengths[i])   # zeros para valores válidos
    }
  })
)

resultado

```

### B)

```{r}
falhas <- resultado > 0

r <- rle(falhas)

# Numerar cada bloco de falha sequencialmente
contador <- 0
vetor_falhas <- unlist(
  lapply(seq_along(r$lengths), function(i) {
    if (r$values[i]) {
      contador <<- contador + 1
      rep(contador, r$lengths[i])
    } else {
      rep(0, r$lengths[i])
    }
  })
)

vetor_falhas

```

### C)

```{r}
falhas_numeradas <- vetor_falhas[vetor_falhas > 0]

tamanho_falhas <- table(falhas_numeradas)
tamanho_falhas <- as.vector(tamanho_falhas)
names(tamanho_falhas) <- paste0("falha", seq_along(tamanho_falhas))
tamanho_falhas

```

### D)

```{r}
maior_falha <- max(tamanho_falhas)
maior_falha
```

## Questão 15

### A)

```{r}
Vh <- c(10, 10, 10, 10, 14.142, 14.142, 14.142, 14.142, 0)
theta <- c(270, 180, 360, 90, 225, 315, 135, 45, 0)

theta_rad <- theta * pi / 180

u <- -Vh * sin(theta_rad)
v <- -Vh * cos(theta_rad)

stringr::str_replace(round(u, 2), "\\.", ",")
stringr::str_replace(round(v, 2), "\\.", ",")

```

### B)

```{r}
u <- c(10, 0, 0, -10, 10, 10, -10, -10, 0)
v <- c(0, 10, -10, 0, 10, -10, 10, -10, 0)

Vh <- sqrt(u^2 + v^2)

theta_mat <- atan2(-u, -v) * 180 / pi

theta <- ifelse(theta_mat < 0, theta_mat + 360, theta_mat)


theta[Vh < 0.5] <- 0

nome_direcao <- function(theta) {
  if(theta == 0) return("Calmo")
  if(theta == 360) return("Norte")
  if(theta == 0) return("Norte")
  if(theta == 90) return("Leste")
  if(theta == 180) return("Sul")
  if(theta == 270) return("Oeste")
  if(theta == 45) return("Nordeste")
  if(theta == 135) return("Sudeste")
  if(theta == 225) return("Sudoeste")
  if(theta == 315) return("Noroeste")
  return(NA)
}

dir <- sapply(theta, nome_direcao)

resultados <- data.frame(u, v, ws = Vh, wd = theta, wd_uv = theta, dir)
resultados

```

## Questão 16

```{r}

prec_obs <- c(
  0, 0, 0, 0.5, 1, 6, 9, 0.2, 1, 0, 0, 0.25,
  10, 15, 8, 3, 0, 0, 0, 0, 0, 0, 0.25, 0,
  0, 0, 1, 5, 0, 20, 0, 0, 0, 0, 1, 1,
  0, 2, 12, 1, 0, 0, 0, 0, 0, 0, 5, 5
)

prec_sim <- c(
  0, 0.2, 0.1, 0, 0, 3, 1, 1, 1, 1, 0, 3,
  0, 10, 4, 1, 0.3, 0.5, 0.5, 0.5, 0.5, 0, 0.25, 0.25,
  0.25, 0, 0.5, 3, 0, 5, 0, 0, 0, 0, 0.5, 0,
  0.25, 0.2, 0, 0.2, 0, 0, 0, 0, 1, 2, 1, 0
)

limite <- 0.25
obs_umb <- prec_obs > limite
sim_umb <- prec_sim > limite

wc <- sum(obs_umb & sim_umb)   
dc <- sum(!obs_umb & !sim_umb)  
wi <- sum(!obs_umb & sim_umb)  
di <- sum(obs_umb & !sim_umb)   
n <- length(prec_obs)           
```

### A)

```{r}
P_C <- (wc + dc) / n
```

A proporção corretamente prevista é de `r stringr::str_replace(P_C, "\\.", ",")`.

### B)

```{r}
CSI <- wc / (wc + wi + di)
```

O índice de sucesso crítico é de `r stringr::str_replace(round(CSI, 4), "\\.", ",")`.

## Questão 17

```{r}
v_obs <- c(
  -0.49, 0.27, -0.48, 0.8, -1, 0.1, -1.16,
  0.58, -1.6, -0.31, 0.45, -0.98, 0.19, 0.73,
  -0.49, -0.04, -0.11, 0.46, 2.02, -1.05
)

v_prev <- c(
  NA, -0.49, 0.27, -0.48, 0.8, -1, 0.1, -1.16,
  0.58, -1.6, -0.31, 0.45, -0.98, 0.19, 0.73,
  -0.49, -0.04, -0.11, 0.46, 2.02
)

valid <- !is.na(v_prev)
obs <- v_obs[valid]
prev <- v_prev[valid]
```

### A)

```{r}
PBIAS <- 100 * sum(prev - obs) / sum(obs)
```

O Viés relativo foi de `r stringr::str_replace(round(PBIAS, 2), "\\.", ",")`.

### B)

```{r}
NSE <- 1 - sum((obs - prev)^2) / sum((obs - mean(obs))^2)
```

O coeficente de eficiência de Nash-Sutcliffe foi de `r stringr::str_replace(round(NSE, 2), "\\.", ",")`.
